<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zzyspace</title>
  <subtitle>iOS Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-19T07:29:41.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zzy</name>
    <email>551854173@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【iOS开发】Objective-c Runtime小记</title>
    <link href="http://yoursite.com/2016/03/16/objective-c-runtime/"/>
    <id>http://yoursite.com/2016/03/16/objective-c-runtime/</id>
    <published>2016-03-16T09:16:08.000Z</published>
    <updated>2016-03-19T07:29:41.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;一-Runtime&quot;&gt;&lt;a href=&quot;#一-Runtime&quot; class=&quot;headerlink&quot; title=&quot;一. Runtime&quot;&gt;&lt;/a&gt;&lt;strong&gt;一. Runtime&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Runtime是一套底层的C语言API. 实际上, 平时我们编写的Objective-C代码, 底层都是基于runtime实现的, 也就是说, 平时我们编写的Objective-C代码, 最终都是转成了底层的runtime代码(C语言代码). Runtime使得Objective-C这门语言的灵活性大大地提升. 有了runtime, 我们可以在应用运行的时候动态操作对象、类、方法, 也因为这个原因, 使得编程有了更多的可能性, 对于开发中遇到的一些比较棘手的问题, 往往用runtime可以优雅地解决, 接下来让我们看看runtime是为何可以如此牛x.&lt;/p&gt;
&lt;h1 id=&quot;二-Objective-C中类和对象的本质&quot;&gt;&lt;a href=&quot;#二-Objective-C中类和对象的本质&quot; class=&quot;headerlink&quot; title=&quot;二. Objective-C中类和对象的本质&quot;&gt;&lt;/a&gt;&lt;strong&gt;二. Objective-C中类和对象的本质&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-对象-Instance&quot;&gt;&lt;a href=&quot;#1-对象-Instance&quot; class=&quot;headerlink&quot; title=&quot;1. 对象(Instance)&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 对象(Instance)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;概念:&lt;/strong&gt;&lt;br&gt;对象的本质是一个结构体, 在&lt;code&gt;&amp;lt;objc/objc.h&amp;gt;&lt;/code&gt;中可以找到它的声明:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;: 指针指向对象所属的类(Class), Class结构体中包含了成员变量、对象方法等等.  &lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt;&lt;br&gt;平常我们常常使用&lt;code&gt;id&lt;/code&gt;来作为对象的指针, 原因就是&lt;code&gt;&amp;lt;objc/objc.h&amp;gt;&lt;/code&gt;中定义&lt;code&gt;id&lt;/code&gt;类型来代替&lt;code&gt;struct objc_object *&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object *&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-类-Class&quot;&gt;&lt;a href=&quot;#2-类-Class&quot; class=&quot;headerlink&quot; title=&quot;2. 类(Class)&quot;&gt;&lt;/a&gt;&lt;strong&gt;2. 类(Class)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;概念:&lt;/strong&gt;&lt;br&gt;类的本质是一个Class类型的对象. 在&lt;code&gt;&amp;lt;objc/runtime.h&amp;gt;&lt;/code&gt;中, 对类的声明如下:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class                                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size                                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols                     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;: 指针指向Class对象的元类(MetaClass), 元类中记录了类方法列表.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super_class&lt;/code&gt;: 指针指向父类. 根类(NSObject)中的super_class指针为空.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;: 类名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;version&lt;/code&gt;: 类的版本, 默认为0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt;: 类的信息, 因为是long型的, 推测是作为标识使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance_size&lt;/code&gt;: 类的对象的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ivars&lt;/code&gt;: 存放该类所有成员变量的链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;methodLists&lt;/code&gt;: 存放该类所有对象方法的链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cache&lt;/code&gt;: 缓存常用的对象方法, 提高消息分发的效率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protocols&lt;/code&gt;: 存放该类的协议的链表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt;&lt;br&gt;就像&lt;code&gt;id&lt;/code&gt;类型代表对象指针一样, &lt;code&gt;&amp;lt;objc/objc.h&amp;gt;&lt;/code&gt;中定义&lt;code&gt;Class&lt;/code&gt;类型来代替&lt;code&gt;struct objc_class *&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-元类-MetaClass&quot;&gt;&lt;a href=&quot;#3-元类-MetaClass&quot; class=&quot;headerlink&quot; title=&quot;3. 元类(MetaClass)&quot;&gt;&lt;/a&gt;&lt;strong&gt;3. 元类(MetaClass)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;概念:&lt;/strong&gt;&lt;br&gt;元类也是一个类, 每个类都有对应的一个元类. 可以通过类中的isa指针找到其对应的元类. 虽然在runtime相关头文件中没有找到MetaClass的声明, 但是在&lt;a href=&quot;http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个博客&lt;/a&gt;中对元类的与类的关系解释中, 我们可以推测出元类结构体和类是相似的, 包含(但不仅有)如下成员:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;: 指针都是指向根元类(NSObject的元类), 即使是根元类本身的isa也是指向自己&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super_class&lt;/code&gt;: 指针指向父元类, 根元类指向根类(NSObject)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;methodLists&lt;/code&gt;: 存放该类的所有类方法的链表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对象、类、元类的关系图：&lt;/strong&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/img/runtime/runtime_0.pdf&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;h1 id=&quot;三-消息机制&quot;&gt;&lt;a href=&quot;#三-消息机制&quot; class=&quot;headerlink&quot; title=&quot;三. 消息机制&quot;&gt;&lt;/a&gt;&lt;strong&gt;三. 消息机制&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;我们平常所说的”方法调用”, 其实是不准确的, 因为在Objective-C中, 所谓的”方法调用”本质是消息分发. 比如下面这个”方法调用”:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[receiver message]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终会被编译器转化为:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(receiver, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(message))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以说, 消息分发是通过定义在&lt;code&gt;&amp;lt;objc/message.h&amp;gt;&lt;/code&gt;中的&lt;code&gt;objc_msgSend()&lt;/code&gt;方法以及相关的方法来实现的. &lt;/p&gt;
&lt;p&gt;需要注意的是消息分发是运行时特性, 说白了就是运行的时候, 一条消息才会知道它所对应的方法的实现是什么. 所以运行的时候, 一条消息的传递过程是这样的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;向对象&lt;code&gt;receiver&lt;/code&gt;对象发送&lt;code&gt;message&lt;/code&gt;消息.&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;receiver&lt;/code&gt;对象的&lt;code&gt;isa&lt;/code&gt;指针找到它的Class.&lt;/li&gt;
&lt;li&gt;在Class结构体中的&lt;code&gt;cache&lt;/code&gt;中查找是否有的&lt;code&gt;message&lt;/code&gt;的selector, 没有的话到&lt;code&gt;methodLists&lt;/code&gt;里面查找. 若有找到&lt;code&gt;message&lt;/code&gt;的selector, 则跳转至对应的方法实现完成此次消息分发.&lt;/li&gt;
&lt;li&gt;如果没有找到&lt;code&gt;message&lt;/code&gt;的实现, &lt;code&gt;objc_msgSend&lt;/code&gt;会通过当前的Class结构体中的&lt;code&gt;super_class&lt;/code&gt;指针找到它的父Class, 并重复第3点的动作. &lt;/li&gt;
&lt;li&gt;如果一直没有找到&lt;code&gt;message&lt;/code&gt;的实现, 第3点与第4点会一直重复直到根类(NSObject).&lt;/li&gt;
&lt;li&gt;如果在根类中依然没有找到&lt;code&gt;message&lt;/code&gt;的实现, 默认(未实现&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;消息转发&lt;/a&gt;方法的情况下)就会抛出&lt;code&gt;unrecognized selector send to instance xxxx&lt;/code&gt;的异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里引用&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple官方文档&lt;/a&gt;的消息分发原理插图便于理解:&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/img/runtime/runtime_1.gif&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;看到这里或许会担心消息分发的过程太过于繁琐, 以至于影响性能? 其实不会的, 一个类中常用的方法会缓存在&lt;code&gt;cache&lt;/code&gt;中, 如上面消息分发流程的第2点所说, 一个对象接收到一条消息之后, 并不是直接去&lt;code&gt;methodLists&lt;/code&gt;查找, 而是先在&lt;code&gt;cache&lt;/code&gt;中查找, 查找不到了再到&lt;code&gt;methodLists&lt;/code&gt;中查找. 这样就能使得消息转发的效率得到保障.&lt;/p&gt;
&lt;h1 id=&quot;扩展阅读&quot;&gt;&lt;a href=&quot;#扩展阅读&quot; class=&quot;headerlink&quot; title=&quot;扩展阅读&quot;&gt;&lt;/a&gt;扩展阅读&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;1.&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C Runtime Programming Guide&lt;/a&gt; by Apple&lt;br&gt;2.&lt;a href=&quot;http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C Runtime 运行时系列文章&lt;/a&gt; by 南峰子&lt;br&gt;3.&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C Runtime&lt;/a&gt; by 玉令天下&lt;br&gt;4.&lt;a href=&quot;http://limboy.me/ios/2013/08/03/dynamic-tips-and-tricks-with-objective-c.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(译)Objective-C的动态特性&lt;/a&gt; by Limboy’s HQ&lt;br&gt;5.&lt;a href=&quot;http://blog.ibireme.com/2013/11/26/objective-c-messaging/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C 中的消息与消息转发&lt;/a&gt; by ibireme&lt;br&gt;6.&lt;a href=&quot;http://tech.glowing.com/cn/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C Runtime&lt;/a&gt; by Glow技术团队博客&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-Runtime&quot;&gt;&lt;a href=&quot;#一-Runtime&quot; class=&quot;headerlink&quot; title=&quot;一. Runtime&quot;&gt;&lt;/a&gt;&lt;strong&gt;一. Runtime&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Runtime是一套底层的C语言API. 实际上, 平时我们编写的Objective-C代码, 底层都是基于runtime实现的, 也就是说, 平时我们编写的Objective-C代码, 最终都是转成了底层的runtime代码(C语言代码). Runtime使得Objective-C这门语言的灵活性大大地提升. 有了runtime, 我们可以在应用运行的时候动态操作对象、类、方法, 也因为这个原因, 使得编程有了更多的可能性, 对于开发中遇到的一些比较棘手的问题, 往往用runtime可以优雅地解决, 接下来让我们看看runtime是为何可以如此牛x.&lt;/p&gt;
&lt;h1 id=&quot;二-Objective-C中类和对象的本质&quot;&gt;&lt;a href=&quot;#二-Objective-C中类和对象的本质&quot; class=&quot;headerlink&quot; title=&quot;二. Objective-C中类和对象的本质&quot;&gt;&lt;/a&gt;&lt;strong&gt;二. Objective-C中类和对象的本质&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-对象-Instance&quot;&gt;&lt;a href=&quot;#1-对象-Instance&quot; class=&quot;headerlink&quot; title=&quot;1. 对象(Instance)&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 对象(Instance)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;概念:&lt;/strong&gt;&lt;br&gt;对象的本质是一个结构体, 在&lt;code&gt;&amp;lt;objc/objc.h&amp;gt;&lt;/code&gt;中可以找到它的声明:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;: 指针指向对象所属的类(Class), Class结构体中包含了成员变量、对象方法等等.  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>【iOS开发】Apple Pay 的集成</title>
    <link href="http://yoursite.com/2016/02/18/apple-pay/"/>
    <id>http://yoursite.com/2016/02/18/apple-pay/</id>
    <published>2016-02-18T13:19:14.000Z</published>
    <updated>2016-03-19T06:38:57.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/img/ApplePay/header.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Apple Pay在今天终于在中国大陆地区正式开通. Apple Pay不仅仅在线下支付中可以让你通过指纹刷(zhuang)卡(bi), 更可以在线上支付(App中支付)时, 节省掉很多多余的步骤, 让支付宝与微信支付哭晕在厕所… 蛋扯远了, 接下来我们来看看怎么让你的App也支持Apple Pay吧!&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;App集成Apple-Pay&quot;&gt;&lt;a href=&quot;#App集成Apple-Pay&quot; class=&quot;headerlink&quot; title=&quot;App集成Apple Pay&quot;&gt;&lt;/a&gt;&lt;strong&gt;App集成Apple Pay&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-创建Merchant-ID&quot;&gt;&lt;a href=&quot;#1-创建Merchant-ID&quot; class=&quot;headerlink&quot; title=&quot;1. 创建Merchant ID&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 创建Merchant ID&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在iOS开发者中心的&lt;a href=&quot;https://developer.apple.com/account/ios/identifiers/merchant/merchantCreate.action&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Certificates, Identifiers &amp;amp; Profiles页面&lt;/a&gt;中创建一个Merchant ID. (PS:前提是你得有开发者帐号= =)&lt;br&gt;&lt;code&gt;Description&lt;/code&gt;: 这个ID的描述, 建议填写App名称.&lt;br&gt;&lt;code&gt;ID&lt;/code&gt;: Merchent ID的标识符, 一般填写”merchant.&lt;code&gt;BundleID&lt;/code&gt;“, 比如&lt;code&gt;merchant.com.apple.passbook&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;2-工程中配置Apple-Pay&quot;&gt;&lt;a href=&quot;#2-工程中配置Apple-Pay&quot; class=&quot;headerlink&quot; title=&quot;2. 工程中配置Apple Pay&quot;&gt;&lt;/a&gt;&lt;strong&gt;2. 工程中配置Apple Pay&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;你的开发者帐号拥有Merchant ID之后, 就需要在工程中配置你刚刚创建的Merchant ID.&lt;br&gt;&lt;img src=&quot;/img/ApplePay/image_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;按照如图顺序即可在你的工程中激活你的Merchant ID.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;未完待续…&quot;&gt;&lt;a href=&quot;#未完待续…&quot; class=&quot;headerlink&quot; title=&quot;未完待续…&quot;&gt;&lt;/a&gt;&lt;strong&gt;未完待续…&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Apple Pay需要在支付提供商上面注册商户. 目前Apple Pay支持的提供商有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://open.unionpay.com/ajweb/product/detail?id=80&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CUP&lt;/a&gt; (中国银联) &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://apple.lianlianpay.com/OpenPlatform/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lianlian Pay&lt;/a&gt; (连连支付) &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.beijing.com.cn/product/ApplePay_ch.jsp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PayEase&lt;/a&gt; (首信易支付) &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yeepay.com/article/specialActivities/queryArticle/56c676b814a6d961550c90eb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YeePay&lt;/a&gt; (易宝支付) &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你的App要上架App Store的话, 在苹果官方&lt;a href=&quot;https://developer.apple.com/app-store/review/guidelines/#apple-pay&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;App Store Review Guidelines&lt;/a&gt;中关于Apple Pay的条款需要特别注意:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;29.1 使用Apple Pay的应用程序必须在出售任何商品或者服务之前为用户提供所有材料的购买信息，否则将会被拒绝。使用Apple Pay的应用程序提供多次付款的，至少要公开再次支付的时间长度，和这种状态将持续到取消为止的每一个时期需要用户提供什么，和将产生的费用，以及如何取消。&lt;/p&gt;
&lt;p&gt;29.2 使用Apple Pay的应用程序必须正确使用 Apple Pay Human Interface Guidelines 中的Apple Pay标识和用户界面元素，否则将会被拒绝。&lt;/p&gt;
&lt;p&gt;29.3 使用Apple Pay的应用程序不能提供触犯任何领域范围法律的用于交付的商品或者服务，也不能用作任何非法目的。&lt;/p&gt;
&lt;p&gt;29.4 使用Apple Pay的应用程序必须提供隐私政策，否则将会被拒绝。 &lt;/p&gt;
&lt;p&gt;29.5 只有为了促进或提高商品和服务的交付，或者依照法律要求，使用Apple Pay的应用程序才能与第三方分享通过Apple Pay获得的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;设计规范&quot;&gt;&lt;a href=&quot;#设计规范&quot; class=&quot;headerlink&quot; title=&quot;设计规范&quot;&gt;&lt;/a&gt;&lt;strong&gt;设计规范&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/apple-pay/Apple-Pay-Identity-Guidelines.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple Pay 标识指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/services-account/download?path=/ios/apple_pay_resources/Apple_Pay_Resources.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple Pay 图标资源包&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/ApplePay/header.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Apple Pay在今天终于在中国大陆地区正式开通. Apple Pay不仅仅在线下支付中可以让你通过指纹刷(zhuang)卡(bi), 更可以在线上支付(App中支付)时, 节省掉很多多余的步骤, 让支付宝与微信支付哭晕在厕所… 蛋扯远了, 接下来我们来看看怎么让你的App也支持Apple Pay吧!&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Apple Pay" scheme="http://yoursite.com/tags/Apple-Pay/"/>
    
  </entry>
  
  <entry>
    <title>【iOS开发】Associated Objects-为分类添加属性</title>
    <link href="http://yoursite.com/2016/01/25/associated-objects/"/>
    <id>http://yoursite.com/2016/01/25/associated-objects/</id>
    <published>2016-01-25T07:06:34.000Z</published>
    <updated>2016-03-19T06:38:57.000Z</updated>
    
    <content type="html">&lt;p&gt;分类(&lt;code&gt;category&lt;/code&gt;)在iOS开发中的应用非常广泛, 优点譬如给现有的类拓展更多的方法、对一个类的多种功能进行局部化封装等等, 都是非常方便的. 但是也有一个痛点, 就是分类中无法添加属性. 但是&lt;code&gt;Objective-C&lt;/code&gt;的&lt;code&gt;runtime&lt;/code&gt;中有许多黑科技可以帮我们实现很多常规方法下几乎不可能的事情–比如在分类中添加属性.这个黑科技叫做&lt;strong&gt;关联对象&lt;/strong&gt;(&lt;code&gt;Associated Objects&lt;/code&gt;). &lt;/p&gt;
&lt;h1 id=&quot;Associated-Objects&quot;&gt;&lt;a href=&quot;#Associated-Objects&quot; class=&quot;headerlink&quot; title=&quot;Associated Objects&quot;&gt;&lt;/a&gt;&lt;strong&gt;Associated Objects&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;关联对象相关的函数有以下3个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;objc_setAssociatedObject&lt;/code&gt; : 设置关联对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objc_getAssociatedObject&lt;/code&gt; : 获取关联对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objc_removeAssociatedObjects&lt;/code&gt; : 移除某个对象的所有关联对象&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;从&lt;code&gt;&amp;lt;objc/runtime.h&amp;gt;&lt;/code&gt;中可以找到它的相关函数定义:&lt;/p&gt;
&lt;h3 id=&quot;1-设置关联对象&quot;&gt;&lt;a href=&quot;#1-设置关联对象&quot; class=&quot;headerlink&quot; title=&quot;1. 设置关联对象&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 设置关联对象&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value, objc_AssociationPolicy policy)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;object&lt;/code&gt; : 需要设置关联对象的对象, &lt;code&gt;id&lt;/code&gt;类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt; : 关联对象的key, &lt;code&gt;const void *&lt;/code&gt;类型 (&lt;em&gt;详细请看下文第4点&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; : 关联对象的值, &lt;code&gt;id&lt;/code&gt;类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;policy&lt;/code&gt; : 关联对象的策略, &lt;code&gt;objc_AssociationPolicy&lt;/code&gt;类型&lt;ul&gt;
&lt;li&gt;&lt;code&gt;policy&lt;/code&gt;是一个枚举类型, 用于修饰关联对象:&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_ASSIGN&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,          &lt;span class=&quot;comment&quot;&gt;// 等价于 @property (assign) 或 @property (unsafe_unretained)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_RETAIN_NONATOMIC&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;// 等价于 @property (nonatomic, strong)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_COPY_NONATOMIC&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;// 等价于 @property (nonatomic, copy)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_RETAIN&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;01401&lt;/span&gt;,      &lt;span class=&quot;comment&quot;&gt;// 等价于 @property (atomic, strong)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_COPY&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;01403&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;// 等价于 @property (atomic, copy)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-获取关联对象&quot;&gt;&lt;a href=&quot;#2-获取关联对象&quot; class=&quot;headerlink&quot; title=&quot;2. 获取关联对象&quot;&gt;&lt;/a&gt;&lt;strong&gt;2. 获取关联对象&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;object&lt;/code&gt; : 获取关联对象的对象, &lt;code&gt;id&lt;/code&gt;类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt; : 关联对象的key, &lt;code&gt;const void *&lt;/code&gt;类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-移除某个对象的所有关联对象&quot;&gt;&lt;a href=&quot;#3-移除某个对象的所有关联对象&quot; class=&quot;headerlink&quot; title=&quot;3. 移除某个对象的所有关联对象&quot;&gt;&lt;/a&gt;&lt;strong&gt;3. 移除某个对象的所有关联对象&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; objc_removeAssociatedObjects(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;object&lt;/code&gt; : 需要移除所有关联对象的对象, &lt;code&gt;id&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注: 这个函数是用来移除对象的&lt;strong&gt;所有&lt;/strong&gt;关联对象, 而非移除对象的某个关联对象. 这个函数Apple官方文档是这么说的&lt;/em&gt; :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should not use this function for general removal of associations from objects, since it also removes associations that other clients may have added to the object. Typically you should use objc_setAssociatedObject with a nil value to clear an association.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;意思是如果要移除对象的某个关联对象, 应该使用&lt;code&gt;objc_setAssociatedObject&lt;/code&gt;对参数&lt;code&gt;value&lt;/code&gt;置nil.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-关于参数-key&quot;&gt;&lt;a href=&quot;#4-关于参数-key&quot; class=&quot;headerlink&quot; title=&quot;4. 关于参数-key&quot;&gt;&lt;/a&gt;&lt;strong&gt;4. 关于参数-key&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;这个key一般只要赋值一个&lt;code&gt;static char&lt;/code&gt;的地址就行, 比如:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; kAssociatedObjectKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &amp;amp;kAssociatedObjectKey);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是还有更简单的方法, 可以使用&lt;code&gt;selector&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(associatedObject));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者直接使用&lt;code&gt;_cmd&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, _cmd);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;关于&lt;code&gt;_cmd&lt;/code&gt;&lt;/em&gt; :&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Apple的文档是是这么解释的: &lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The _cmd variable is a hidden argument passed to every method that is the current selector&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;意思就是&lt;code&gt;_cmd&lt;/code&gt;在Objective-C的方法中表示当前方法的&lt;code&gt;selector&lt;/code&gt;, 正如同&lt;code&gt;self&lt;/code&gt;表示调用当前方法的对象(类)一样.&lt;/em&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Simple-Example&quot;&gt;&lt;a href=&quot;#Simple-Example&quot; class=&quot;headerlink&quot; title=&quot;Simple Example&quot;&gt;&lt;/a&gt;&lt;strong&gt;Simple Example&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;AssociatedObject&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; associatedObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;AssociatedObject&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  对象的setter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setAssociatedObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(associatedObject), object, OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_RETAIN_NONATOMIC&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  对象的getter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)associatedObject &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(associatedObject));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;1.&lt;a href=&quot;http://nshipster.com/associated-objects/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Associated Objects&lt;/a&gt; by Mattt&lt;br&gt;2.&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/func/objc_getAssociatedObject&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C Runtime Reference&lt;/a&gt; by Apple&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;分类(&lt;code&gt;category&lt;/code&gt;)在iOS开发中的应用非常广泛, 优点譬如给现有的类拓展更多的方法、对一个类的多种功能进行局部化封装等等, 都是非常方便的. 但是也有一个痛点, 就是分类中无法添加属性. 但是&lt;code&gt;Objective-C&lt;/code&gt;的&lt;code&gt;runtime&lt;/code&gt;中有许多黑科技可以帮我们实现很多常规方法下几乎不可能的事情–比如在分类中添加属性.这个黑科技叫做&lt;strong&gt;关联对象&lt;/strong&gt;(&lt;code&gt;Associated Objects&lt;/code&gt;). &lt;/p&gt;
&lt;h1 id=&quot;Associated-Objects&quot;&gt;&lt;a href=&quot;#Associated-Objects&quot; class=&quot;headerlink&quot; title=&quot;Associated Objects&quot;&gt;&lt;/a&gt;&lt;strong&gt;Associated Objects&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;关联对象相关的函数有以下3个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;objc_setAssociatedObject&lt;/code&gt; : 设置关联对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objc_getAssociatedObject&lt;/code&gt; : 获取关联对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objc_removeAssociatedObjects&lt;/code&gt; : 移除某个对象的所有关联对象&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>【iOS Tip】UIImage的renderingMode</title>
    <link href="http://yoursite.com/2015/03/29/uiimage-rendering-mode/"/>
    <id>http://yoursite.com/2015/03/29/uiimage-rendering-mode/</id>
    <published>2015-03-29T06:32:22.000Z</published>
    <updated>2016-03-19T06:38:57.000Z</updated>
    
    <content type="html">&lt;p&gt;很多人在第一次使用UITabBar的时候, 都会遇到一个摸不着头脑的问题:&lt;br&gt;明明UI给的图片是这样的 ↓&lt;br&gt;&lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可是用到tabBar中却变成了这样 ↓&lt;br&gt;&lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;WTF!&lt;/strong&gt; 咋还自己变色了呢? &lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;其实以上的现象都是源于UIImage的一个属性&lt;code&gt;renderingMode&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;UIImageRenderingMode&quot;&gt;&lt;a href=&quot;#UIImageRenderingMode&quot; class=&quot;headerlink&quot; title=&quot;UIImageRenderingMode&quot;&gt;&lt;/a&gt;&lt;strong&gt;UIImageRenderingMode&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 概念&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIImageRenderingMode&lt;/span&gt; renderingMode &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;code&gt;UIImageRenderingMode&lt;/code&gt;是一个枚举值, 如下:&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIImageRenderingMode&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImageRenderingModeAutomatic&lt;/span&gt;,      &lt;span class=&quot;comment&quot;&gt;// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImageRenderingModeAlwaysOriginal&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 始终渲染图片的原始状态, 不会将其当做一个模板(template).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImageRenderingModeAlwaysTemplate&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 始终把图片当做模板来渲染, 忽略掉了图片的颜色信息.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个UIImage的时候, 默认的&lt;strong&gt;renderingMode&lt;/strong&gt;为&lt;code&gt;UIImageRenderingModeAutomatic&lt;/code&gt;. 这种情况下, 图片会根据当前所处的上下文来决定是渲染图片的原始状态或是当做模板来渲染.&lt;br&gt;例如&lt;code&gt;UINavigationBar&lt;/code&gt;、&lt;code&gt;UITabBar&lt;/code&gt;、&lt;code&gt;UIToolBar&lt;/code&gt;、&lt;code&gt;UISegmentedControl&lt;/code&gt;这些控件, 会自动把其上面的图片(foreground images)当做模板来渲染; 而&lt;code&gt;UIImageView&lt;/code&gt;、&lt;code&gt;UIWebView&lt;/code&gt;则会渲染图片的原始状态.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于&lt;strong&gt;模板(template)&lt;/strong&gt;: 上文中提到的模板, 其实作用就是忽略掉了图片的所有不透明的颜色信息, 取而代之的是它所在的控件的&lt;code&gt;tintColor&lt;/code&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-应用&quot;&gt;&lt;a href=&quot;#2-应用&quot; class=&quot;headerlink&quot; title=&quot;2. 应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;2. 应用&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;根据上面对&lt;strong&gt;renderingMode&lt;/strong&gt;的描述, 我们就可以很容易联想到导致文章开头那个现象的原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UITabBar会自动将图片当做模板来渲染&lt;/li&gt;
&lt;li&gt;UITabBar默认的&lt;code&gt;tintColor&lt;/code&gt;是系统的亮蓝色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以, 相应的解决方法也有两种:&lt;br&gt;&lt;strong&gt;1.设置图片的renderingMode为&lt;code&gt;UIImageRenderingModeAlwaysOriginal&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *selectedImage = [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:selectedImageName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;originalSelectedImage = [selectedImage imageWithRenderingMode:&lt;span class=&quot;built_in&quot;&gt;UIImageRenderingModeAlwaysOriginal&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;viewController&lt;span class=&quot;variable&quot;&gt;.tabBarItem&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.selectedImage&lt;/span&gt; = originalSelectedImage;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.设置UITabBar的&lt;code&gt;tintColor&lt;/code&gt;为我们所要的颜色.&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tabBar&lt;span class=&quot;variable&quot;&gt;.tintColor&lt;/span&gt; = kAppMainColor;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-其他&quot;&gt;&lt;a href=&quot;#3-其他&quot; class=&quot;headerlink&quot; title=&quot;3. 其他&quot;&gt;&lt;/a&gt;&lt;strong&gt;3. 其他&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;如果总是在代码中设置&lt;strong&gt;renderingMode&lt;/strong&gt;也是比较麻烦的, 还有一个更佳便捷的设置方法, 如下图在&lt;code&gt;Images.xcassets&lt;/code&gt;里面选中相应的图片, 在右侧的工具栏中的&lt;code&gt;Render As&lt;/code&gt;字段选择相应的&lt;strong&gt;renderingMode&lt;/strong&gt;就可以了.&lt;br&gt;&lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很多人在第一次使用UITabBar的时候, 都会遇到一个摸不着头脑的问题:&lt;br&gt;明明UI给的图片是这样的 ↓&lt;br&gt;&lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可是用到tabBar中却变成了这样 ↓&lt;br&gt;&lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;WTF!&lt;/strong&gt; 咋还自己变色了呢? &lt;img src=&quot;/img/UIImageRenderingMode/renderingMode_2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;其实以上的现象都是源于UIImage的一个属性&lt;code&gt;renderingMode&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;UIImageRenderingMode&quot;&gt;&lt;a href=&quot;#UIImageRenderingMode&quot; class=&quot;headerlink&quot; title=&quot;UIImageRenderingMode&quot;&gt;&lt;/a&gt;&lt;strong&gt;UIImageRenderingMode&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 概念&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIImageRenderingMode&lt;/span&gt; renderingMode &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS Tips" scheme="http://yoursite.com/categories/iOS-Tips/"/>
    
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
</feed>
